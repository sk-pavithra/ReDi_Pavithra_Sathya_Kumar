# -*- coding: utf-8 -*-
"""ReDI_Project_Pavithra_Sathya_Kumar

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1P6q4DtjW4qHoW5aCw_YFRZb7VbV_WCDQ

FLight Data Analysis using ML
"""

# load the dataset
from google.colab import files
uploaded = files.upload()

#read the data

import pandas as pd
import numpy as np

df = pd.read_csv("flights.csv")

#show the datatype and missing values if any
df.info()

#rows and column
df.shape

df.describe(include='all')

#check for missing value
df.isna().sum()

#airport counts
df['APT_ICAO'].nunique()

df['STATE_NAME'].nunique()

"""Introduction

Expolatory data Analysis:

**IFR = Instrument Flight Rules**

Not all airports fly IFR flights daily (especially small airports), and sometimes countries simply do not report IFR traffic.

if IFR missing → treat as 0
"""

#Handling IFR Missing Values

# if IFR = 0, missing data
df[['FLT_DEP_IFR_2','FLT_ARR_IFR_2','FLT_TOT_IFR_2']] = (
    df[['FLT_DEP_IFR_2','FLT_ARR_IFR_2','FLT_TOT_IFR_2']].fillna(0)
)

#keep data type as 'int'
df[['FLT_DEP_IFR_2','FLT_ARR_IFR_2','FLT_TOT_IFR_2']] = (
    df[['FLT_DEP_IFR_2','FLT_ARR_IFR_2','FLT_TOT_IFR_2']].astype(int)
)

#check if the missing data is filled correctly

df.isna().sum()

#airport codes by ICAO
df['APT_ICAO'].unique()

#airport name and its count
df['APT_NAME'].value_counts()

#Country names-airport
df['STATE_NAME'].value_counts()

# whats the Daily Flight Trends?

df_daily = df.groupby('FLT_DATE')['FLT_TOT_1'].sum().reset_index()

#lets visualize daily trends
df_daily.plot(x='FLT_DATE', y='FLT_TOT_1', figsize=(12,5), title="Total Daily Flights in Europe")

# Flight traffic based on EU country

country_flights = df.groupby('STATE_NAME')['FLT_TOT_1'].sum().sort_values(ascending=False)
country_flights.head(15).plot(kind='bar', figsize=(12,5), title="Flights by Country (Top 15)")

#Which airports rely more on IFR operations?
import numpy as np
df['IFR_ratio'] = np.where(df['FLT_TOT_1'] == 0, 0, df['FLT_TOT_IFR_2'] / df['FLT_TOT_1'])

df['IFR_ratio'].plot(kind='hist', bins=30, figsize=(10,5),
                    title="Distribution of IFR Ratio Across Airports")

#sesonal trends in flight operation

monthly = df.groupby('MONTH_NUM')['FLT_TOT_1'].mean()
monthly.plot(kind='bar', figsize=(10,5), title="Average Flights Per Month")

"""This aids in interpreting aviation flight operation on weather conditions:

VFR = Visual Flight Rules
These are flights where pilots navigate using visual references (looking outside), not relying heavily on instruments or air traffic control.

If weather becomes poor:
*   VFR flights get cancelled
*   Traffic drops

IFR airports continue operations even in:

* Fog
* Low visibility
* Rain
* Snow

Northern Europe = more weather challenges → highly depended on IFR

Southern Europe = more VFR traffic (good weather)
"""

#which airports rely most on IFR operations?
airport_ifr = df.groupby('Pivot Label')['IFR_ratio'].mean().sort_values(ascending=False)
airport_ifr.head(15)

airport_ifr.head(15).plot(kind='bar', figsize=(12,5),
                          title="Top 15 Airports by IFR Dependency")

#which EU country relays on IFR

country_ifr = df.groupby('STATE_NAME')['IFR_ratio'].mean().sort_values(ascending=False)

country_ifr.plot(kind='bar', figsize=(12,5),
                 title="Average IFR Ratio by Country")

# which airport has top IFR usage
top_ifr = df.groupby(['APT_ICAO','APT_NAME'])['IFR_ratio'].mean()\
            .sort_values(ascending=False).head(10)

for icao, val in top_ifr.items():
    print(f"{icao[0]} ({icao[1]}): {val:.2f}")

import matplotlib.pyplot as plt

# Remove extreme ratios
df_clean = df[df['IFR_ratio'] <= 1.5]

plt.figure(figsize=(10,5))
df_clean['IFR_ratio'].plot(kind='hist', bins=40)
plt.title("Distribution of IFR Ratio (Cleaned)")
plt.xlabel("IFR_ratio")
plt.ylabel("Frequency")
plt.show()

# Which airports have the MOST traffic?
df.groupby('APT_NAME')['FLT_TOT_1'].sum().sort_values(ascending=False).head(20)

#low traffic
df.groupby(['APT_ICAO', 'APT_NAME'])['FLT_TOT_1'].sum().sort_values().head(20)

#when is the peak traffic observed at airport

df.groupby(['APT_ICAO', 'APT_NAME','MONTH_NUM'])['FLT_TOT_1'].mean()

import matplotlib.pyplot as plt

# Calculate the grouped mean
airport_monthly_avg = df.groupby(['APT_ICAO', 'APT_NAME', 'MONTH_NUM'])['FLT_TOT_1'].mean()

# Identify top 10 airports by overall total flights for a clearer visualization
top_10_airports = df.groupby(['APT_ICAO','APT_NAME'])['FLT_TOT_1'].sum().nlargest(10).index

# Filter the grouped data for these top 10 airports using .isin() for MultiIndex compatibility
mask = airport_monthly_avg.index.isin(top_10_airports)
top_airport_monthly_avg = airport_monthly_avg[mask]

# Unstack to get months as columns,
top_airport_monthly_pivot = top_airport_monthly_avg.unstack(level='MONTH_NUM')

# Plotting the average monthly flights for the top 10 airports
plt.figure(figsize=(14, 7))
top_airport_monthly_pivot.T.plot(kind='line', ax=plt.gca())
plt.title('Average Monthly Flights for Top 10 Airports')
plt.xlabel('Month Number')
plt.ylabel('Average Total Flights')
plt.xticks(range(1, 13))  # Ensure all month numbers are shown on the x-axis
plt.legend(title='Airport', bbox_to_anchor=(1.05, 1), loc='upper left')
plt.grid(True, linestyle='-', alpha=0.5)
plt.tight_layout()
plt.show()

#print(f"Plotting monthly flight trends for the following top 10 airports: {list(top_10_airports)}")

"""**Build Airport capacity prediction model using ML**

---

Based on EDA, the data consit of Airport Traffic from EU Airpots. this includes date, year, month, airport code, total flights per day, IFR flights per day.

With this information, we can build a airport capacity model to understand how many glights an airport can haldel. Thus this dataset helps to understand the following:
* capture large-scale aviation behavior
* learn patterns from busiest airports
* understand the effect of time (seasonality)
* the effect of IFR operations

Thus regrestion modelling is used.
This modeling can help with operational planning staffing, runway usage and understand the peak travel behaviours to maximize airport capacity.

As the dataset targets the numerical traffic volumes, it does not classify the flights data into high, low or medium, predicting the data based on classification would lose the valuable information. Hence Regression model support the overall analysis.





"""

#import basic libraries

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import warnings
warnings.filterwarnings("ignore")

#ML tools
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score
from sklearn.preprocessing import StandardScaler, OneHotEncoder
from sklearn.compose import ColumnTransformer
from sklearn.pipeline import Pipeline

#date-time
from datetime import timedelta

#Remove noise from small airport for stable traffic, reliable operation and real aviation pattern.

df['FLT_DATE'] = pd.to_datetime(df['FLT_DATE'], utc=True)


# # total traffic per airport
# airport_totals = df.groupby('APT_ICAO')['FLT_TOT_1'].sum().sort_values(ascending=False)

# #sort airport from high traffic to low traffic
# airport_totals = airport_totals.sort_values(ascending=False)

# #from this select top 50 airport for easy traffic understanding : busiest airport
# top_airports = airport_totals.head(50).index

# #top airport data
# df_reg = df[df['APT_ICAO'].isin(top_airports)].copy()

#date-time

df_reg['YEAR'] = df_reg['FLT_DATE'].dt.year
df_reg['MONTH'] = df_reg['FLT_DATE'].dt.month
df_reg['DAYOFWEEK'] = df_reg['FLT_DATE'].dt.dayofweek
df_reg['IS_WEEKEND'] = df_reg['DAYOFWEEK'].isin([5,6]).astype(int)

df_reg = df_reg.sort_values(['APT_ICAO','FLT_DATE'])

df_reg['lag_1']  = df_reg.groupby('APT_ICAO')['FLT_TOT_1'].shift(1)
df_reg['lag_7']  = df_reg.groupby('APT_ICAO')['FLT_TOT_1'].shift(7)
df_reg['lag_30'] = df_reg.groupby('APT_ICAO')['FLT_TOT_1'].shift(30)

df_reg = df_reg.dropna(subset=['lag_1','lag_7','lag_30'])

# Select top 50 busiest airports
airport_totals = df.groupby('APT_ICAO')['FLT_TOT_1'].sum().sort_values(ascending=False)
top_airports = airport_totals.head(50).index

df_reg = df[df['APT_ICAO'].isin(top_airports)].copy()

# Create date/time features
df_reg['YEAR'] = df_reg['FLT_DATE'].dt.year
df_reg['MONTH'] = df_reg['FLT_DATE'].dt.month
df_reg['DAYOFWEEK'] = df_reg['FLT_DATE'].dt.dayofweek
df_reg['IS_WEEKEND'] = df_reg['DAYOFWEEK'].isin([5,6]).astype(int)

# FIXED feature set (no leakage)
feature_cols = [
    'YEAR', 'MONTH', 'DAYOFWEEK', 'IS_WEEKEND',
    'IFR_ratio',
    'APT_ICAO', 'APT_NAME', 'STATE_NAME'
]

X = df_reg[feature_cols].copy()
y = df_reg['FLT_TOT_1'].copy()

# Encode categorical features
X_encoded = pd.get_dummies(
    X,
    columns=['APT_ICAO', 'APT_NAME', 'STATE_NAME'],
    drop_first=True
)

# Train/test split
split_date = pd.Timestamp('2021-01-01', tz='UTC')
train_mask = df_reg['FLT_DATE'] < split_date
test_mask  = df_reg['FLT_DATE'] >= split_date

X_train = X_encoded[train_mask]
X_test = X_encoded[test_mask]
y_train = y[train_mask]
y_test = y[test_mask]

#top 50 airports

plt.figure(figsize=(15,5))
airport_totals.head(50).plot(kind='bar',
                             title="Top 50 Airports by Total Flights",
                             ylabel="Total Flights",
                             xlabel="Airport Names")
plt.show()

#to understand sesonalities, weekly pattern, yearly observation

df_reg['YEAR'] = df_reg['FLT_DATE'].dt.year
df_reg['MONTH'] = df_reg['FLT_DATE'].dt.month
df_reg['DAYOFWEEK'] = df_reg['FLT_DATE'].dt.dayofweek  # 0=Mon
df_reg['IS_WEEKEND'] = df_reg['DAYOFWEEK'].isin([5, 6]).astype(int)


#avg daily flights per month across top airports
monthly_mean = df_reg.groupby('MONTH')['FLT_TOT_1'].mean()

plt.figure(figsize=(8,4))
monthly_mean.plot(kind='bar')
plt.title("Average Daily Flights per Month (Top Airports)")
plt.ylabel("Average FLT_TOT_1")
plt.show()

feature_cols = [
    'YEAR', 'MONTH', 'DAYOFWEEK', 'IS_WEEKEND',
    'IFR_ratio',
    'APT_ICAO', 'APT_NAME', 'STATE_NAME'
]

#inputs
# x-input
# y-target

X = df_reg[feature_cols].copy()
y = df_reg['FLT_TOT_1'].copy()

#airport and country indicator variable

X_encoded = pd.get_dummies(
    X,
    columns=['APT_ICAO', 'APT_NAME', 'STATE_NAME'],  # these two are categorical
    drop_first=True                      # drop one level to avoid collinearity
)

X_encoded.info()

#before covid - train 2016 - 2020
#after covid - test 2021- 2022 mid

#split data
split_date = pd.Timestamp('2021-01-01', tz='UTC')

#train
train_mask = df_reg['FLT_DATE'] < split_date
test_mask  = df_reg['FLT_DATE'] >= split_date

#apply mask
X_train = X_encoded[train_mask]
X_test  = X_encoded[test_mask]
y_train = y[train_mask]
y_test  = y[test_mask]

#check sizes
X_train.shape, X_test.shape

#check which ML model is best?

from sklearn.linear_model import LinearRegression
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score

#model_1
lr = LinearRegression()

#fit on training data
lr.fit(X_train, y_train)

#predict
y_pred_lr = lr.predict(X_test)

# evaluate
mae_lr = mean_absolute_error(y_test, y_pred_lr)
mse_lr = mean_squared_error(y_test, y_pred_lr)
rmse_lr = np.sqrt(mse_lr)
r2_lr = r2_score(y_test, y_pred_lr)

print("Linear Regression Results:")
print("MAE :", mae_lr)
print("RMSE:", rmse_lr)
print("R²  :", r2_lr)

#model_2

#XG Boost

!pip install xgboost

from xgboost import XGBRegressor

xgb = XGBRegressor(
    n_estimators= 500,
    learning_rate=0.05,
    random_state=42,
    n_jobs=-1
)

xgb.fit(X_train, y_train)
y_pred_xgb = xgb.predict(X_test)

# Calculate MSE, RMSE
mse_xgb = mean_squared_error(y_test, y_pred_xgb)
rmse_xgb = np.sqrt(mse_xgb)
mae_xgb = mean_absolute_error(y_test, y_pred_xgb)
r2_xgb = r2_score(y_test, y_pred_xgb)

print("XGBoost Results:")
print("MAE :", mae_xgb)
print("RMSE:", rmse_xgb)
print("R²  :", r2_xgb)

#model_3

#Random forest

from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score
import numpy as np

rf = RandomForestRegressor(
    n_estimators=150,
    max_depth=15,
    random_state=42,
    n_jobs=-1
)

rf.fit(X_train, y_train)
y_pred_rf = rf.predict(X_test)

mae_rf = mean_absolute_error(y_test, y_pred_rf)
mse_rf = mean_squared_error(y_test, y_pred_rf)
rmse_rf = np.sqrt(mse_rf)
r2_rf = r2_score(y_test, y_pred_rf)

print("Random Forest Results:")
print("MAE :", mae_rf)
print("RMSE:", rmse_rf)
print("R²  :", r2_rf)

#compare all models

results = pd.DataFrame({
    'Model': ['Linear Regression', 'XGBoost', 'Random Forest'],
    'MAE': [mae_lr, mae_xgb, mae_rf],
    'RMSE': [rmse_lr, rmse_xgb, rmse_rf],
    'R²': [r2_lr, r2_xgb, r2_rf]
})

results.set_index('Model', inplace=True)
results

importances_rf = pd.Series(rf.feature_importances_, index=X_train.columns)
print("\nRandom Forest Feature Importances (Top 20):")
display(importances_rf.sort_values(ascending=False).head(20))

"""Once the Random Forest feature importances are displayed, we can compare them to those of XGBoost to understand how the two models prioritize different features for their predictions.

### Using the Best Model (XGBoost) for Capacity Prediction

Since the XGBoost model achieved the best performance metrics (MAE, RMSE, R²), we will now use it to make predictions. The `FLT_TOT_1` column, which we have been predicting, represents the total daily flights, serving as a proxy for daily airport capacity utilization.

Now the model needs to understand how many flights a day an airport will have, based on season, airport and do the same for forecasting.

Usually planning happens in statergic (long-term) and tactical(day of operation). For capacitiy predecting, these parameters are required:

* YEAR
* MONTH
* DAYOFWEEK
* IFR_ratio ← NOT same-day IFR values
* lag_1     ← yesterday’s traffic
* lag_7      ← traffic 1 week ago
* lag_30     ← traffic 1 month ago
* APT_ICAO
* STATE_NAME
"""

#identify Germany airports
df_de = df[df['STATE_NAME'] == "Germany"].copy()
df_de.shape

#filter data for busiest airport in germany

airport_totals_de = df_de.groupby(['APT_ICAO', 'APT_NAME'])['FLT_TOT_1'].sum().sort_values(ascending=False)
top_de_airports = airport_totals_de.head(15).index.tolist()

# to filter df_de based on (APT_ICAO, APT_NAME) tuples
df_top_de = df_de[df_de.apply(lambda row: (row['APT_ICAO'], row['APT_NAME']) in top_de_airports, axis=1)].copy()

df_top_de

df_top_de['YEAR'] = df_top_de['FLT_DATE'].dt.year
df_top_de['MONTH'] = df_top_de['FLT_DATE'].dt.month
df_top_de['DAYOFWEEK'] = df_top_de['FLT_DATE'].dt.dayofweek
df_top_de['IS_WEEKEND'] = df_top_de['DAYOFWEEK'].isin([5,6]).astype(int)

df_top_de = df_top_de.sort_values(['APT_ICAO','FLT_DATE'])

df_top_de['lag_1']  = df_top_de.groupby('APT_ICAO')['FLT_TOT_1'].shift(1)
df_top_de['lag_7']  = df_top_de.groupby('APT_ICAO')['FLT_TOT_1'].shift(7)
df_top_de['lag_30'] = df_top_de.groupby('APT_ICAO')['FLT_TOT_1'].shift(30)

df_top_de = df_top_de.dropna(subset=['lag_1','lag_7','lag_30'])

feature_cols = [
    'YEAR','MONTH','DAYOFWEEK','IS_WEEKEND',
    'IFR_ratio',
    'lag_1','lag_7','lag_30',
    'APT_ICAO','APT_NAME'
]

X = df_top_de[feature_cols].copy()
y = df_top_de['FLT_TOT_1'].copy()

X_encoded = pd.get_dummies(X, columns=['APT_ICAO','APT_NAME'], drop_first=True)

split_date = pd.Timestamp('2021-01-01', tz='UTC')

train_idx = df_top_de[df_top_de['FLT_DATE'] < split_date].index
test_idx  = df_top_de[df_top_de['FLT_DATE'] >= split_date].index

X_train = X_encoded.loc[train_idx]
X_test  = X_encoded.loc[test_idx]
y_train = y.loc[train_idx]
y_test  = y.loc[test_idx]

xgb = XGBRegressor(
    n_estimators=500,
    learning_rate=0.05,
    random_state=42,
    n_jobs=-1
)

xgb.fit(X_train, y_train)
y_pred_de = xgb.predict(X_test)

pred_de = pd.DataFrame({
    "Date": df_top_de.loc[test_idx, 'FLT_DATE'],
    "Airport": df_top_de.loc[test_idx, 'APT_ICAO'],
    "Actual": y_test,
    "Predicted": y_pred_de
})

for ap_tuple in top_de_airports:
    icao = ap_tuple[0]  # ('EDDF','Frankfurt') → 'EDDF'

    temp = pred_de[pred_de["Airport"] == icao].sort_values("Date")
    print(icao, temp.shape)

    if temp.empty:
        print(f"Skipping {icao} (no test data).")
        continue

    plt.figure(figsize=(12,4))
    plt.plot(temp["Date"], temp["Actual"], label="Actual")
    plt.plot(temp["Date"], temp["Predicted"], label="Predicted")
    plt.title(f"Capacity Prediction – {ap_tuple[1]} ({icao})")
    plt.ylabel("Flights per Day")
    plt.legend()
    plt.show()

airport_scores = []

for ap_tuple in top_de_airports:
    icao = ap_tuple[0]
    temp = pred_de[pred_de["Airport"] == icao]

    if temp.empty:
        continue

    mae = mean_absolute_error(temp["Actual"], temp["Predicted"])
    mse = mean_squared_error(temp["Actual"], temp["Predicted"])
    rmse = np.sqrt(mse)

    airport_scores.append([icao, ap_tuple[1], mae, rmse])

import pandas as pd
airport_scores_df = pd.DataFrame(airport_scores, columns=["ICAO", "Airport", "MAE", "RMSE"])
airport_scores_df.sort_values("MAE")

importances = pd.Series(xgb.feature_importances_, index=X_train.columns)
importances.sort_values(ascending=False).head(20)

ap = "EDDF"

last = df_top_de[df_top_de["APT_ICAO"] == ap].sort_values("FLT_DATE").iloc[-1]
next_date = last["FLT_DATE"] + pd.Timedelta(days=1)

future_input = pd.DataFrame({
    "YEAR": [next_date.year],
    "MONTH": [next_date.month],
    "DAYOFWEEK": [next_date.dayofweek],
    "IS_WEEKEND": [1 if next_date.dayofweek in [5,6] else 0],
    "IFR_ratio": [last["IFR_ratio"]],
    "lag_1": [last["FLT_TOT_1"]],
    "lag_7": [last["lag_7"]],
    "lag_30": [last["lag_30"]],
    "APT_ICAO": [ap],
    "APT_NAME": [last["APT_NAME"]]
})

future_encoded = pd.get_dummies(future_input).reindex(columns=X_train.columns, fill_value=0)
future_pred = xgb.predict(future_encoded)[0]
print(f"Predicted traffic for {ap} on {next_date.date()}: {future_pred:.0f}")

